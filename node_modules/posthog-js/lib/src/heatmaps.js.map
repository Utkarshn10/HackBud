{"version":3,"file":"heatmaps.js","sourceRoot":"","sources":["../../src/heatmaps.ts"],"names":[],"mappings":"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","sourcesContent":["import { includes, registerEvent } from './utils'\nimport RageClick from './extensions/rageclick'\nimport { DecideResponse, Properties } from './types'\nimport { PostHog } from './posthog-core'\n\nimport { document, window } from './utils/globals'\nimport { getEventTarget, getParentElement, isElementNode, isTag } from './autocapture-utils'\nimport { HEATMAPS_ENABLED_SERVER_SIDE, TOOLBAR_ID } from './constants'\nimport { isEmptyObject, isObject, isUndefined } from './utils/type-utils'\nimport { logger } from './utils/logger'\n\nconst DEFAULT_FLUSH_INTERVAL = 5000\nconst HEATMAPS = 'heatmaps'\nconst LOGGER_PREFIX = '[' + HEATMAPS + ']'\n\ntype HeatmapEventBuffer =\n    | {\n          [key: string]: Properties[]\n      }\n    | undefined\n\nfunction elementOrParentPositionMatches(el: Element | null, matches: string[], breakOnElement?: Element): boolean {\n    let curEl: Element | null | false = el\n\n    while (curEl && isElementNode(curEl) && !isTag(curEl, 'body')) {\n        if (curEl === breakOnElement) {\n            return false\n        }\n\n        if (includes(matches, window?.getComputedStyle(curEl).position)) {\n            return true\n        }\n\n        curEl = getParentElement(curEl)\n    }\n\n    return false\n}\n\nfunction elementInToolbar(el: Element): boolean {\n    // NOTE: .closest is not supported in IE11 hence the operator check\n    return el.id === TOOLBAR_ID || !!el.closest?.('#' + TOOLBAR_ID)\n}\n\nexport class Heatmaps {\n    instance: PostHog\n    rageclicks = new RageClick()\n    _enabledServerSide: boolean = false\n    _initialized = false\n    _mouseMoveTimeout: ReturnType<typeof setTimeout> | undefined\n\n    // TODO: Periodically flush this if no other event has taken care of it\n    private buffer: HeatmapEventBuffer\n    private _flushInterval: ReturnType<typeof setInterval> | null = null\n\n    constructor(instance: PostHog) {\n        this.instance = instance\n        this._enabledServerSide = !!this.instance.persistence?.props[HEATMAPS_ENABLED_SERVER_SIDE]\n\n        window?.addEventListener('beforeunload', () => {\n            this.flush()\n        })\n    }\n\n    public get flushIntervalMilliseconds(): number {\n        let flushInterval = DEFAULT_FLUSH_INTERVAL\n        if (\n            isObject(this.instance.config.capture_heatmaps) &&\n            this.instance.config.capture_heatmaps.flush_interval_milliseconds\n        ) {\n            flushInterval = this.instance.config.capture_heatmaps.flush_interval_milliseconds\n        }\n        return flushInterval\n    }\n\n    public get isEnabled(): boolean {\n        if (!isUndefined(this.instance.config.capture_heatmaps)) {\n            return this.instance.config.capture_heatmaps !== false\n        }\n        if (!isUndefined(this.instance.config.enable_heatmaps)) {\n            return this.instance.config.enable_heatmaps\n        }\n        return this._enabledServerSide\n    }\n\n    public startIfEnabled(): void {\n        if (this.isEnabled) {\n            // nested if here since we only want to run the else\n            // if this.enabled === false\n            // not if this method is called more than once\n            if (this._initialized) {\n                return\n            }\n            logger.info(LOGGER_PREFIX + ' starting...')\n            this._setupListeners()\n            this._flushInterval = setInterval(this.flush.bind(this), this.flushIntervalMilliseconds)\n        } else {\n            clearInterval(this._flushInterval ?? undefined)\n            this.getAndClearBuffer()\n        }\n    }\n\n    public afterDecideResponse(response: DecideResponse) {\n        const optIn = !!response['heatmaps']\n\n        if (this.instance.persistence) {\n            this.instance.persistence.register({\n                [HEATMAPS_ENABLED_SERVER_SIDE]: optIn,\n            })\n        }\n        // store this in-memory in case persistence is disabled\n        this._enabledServerSide = optIn\n        this.startIfEnabled()\n    }\n\n    public getAndClearBuffer(): HeatmapEventBuffer {\n        const buffer = this.buffer\n        this.buffer = undefined\n        return buffer\n    }\n\n    private _setupListeners(): void {\n        if (!window || !document) {\n            return\n        }\n\n        registerEvent(document, 'click', (e) => this._onClick((e || window?.event) as MouseEvent), false, true)\n        registerEvent(document, 'mousemove', (e) => this._onMouseMove((e || window?.event) as MouseEvent), false, true)\n\n        this._initialized = true\n    }\n\n    private _getProperties(e: MouseEvent, type: string): Properties {\n        // We need to know if the target element is fixed or not\n        // If fixed then we won't account for scrolling\n        // If not then we will account for scrolling\n\n        const scrollY = this.instance.scrollManager.scrollY()\n        const scrollX = this.instance.scrollManager.scrollX()\n        const scrollElement = this.instance.scrollManager.scrollElement()\n\n        const isFixedOrSticky = elementOrParentPositionMatches(getEventTarget(e), ['fixed', 'sticky'], scrollElement)\n\n        return {\n            x: e.clientX + (isFixedOrSticky ? 0 : scrollX),\n            y: e.clientY + (isFixedOrSticky ? 0 : scrollY),\n            target_fixed: isFixedOrSticky,\n            type,\n        }\n    }\n\n    private _onClick(e: MouseEvent): void {\n        if (elementInToolbar(e.target as Element)) {\n            return\n        }\n        const properties = this._getProperties(e, 'click')\n\n        if (this.rageclicks?.isRageClick(e.clientX, e.clientY, new Date().getTime())) {\n            this._capture({\n                ...properties,\n                type: 'rageclick',\n            })\n        }\n\n        // TODO: Detect deadclicks\n\n        this._capture(properties)\n    }\n\n    private _onMouseMove(e: Event): void {\n        if (elementInToolbar(e.target as Element)) {\n            return\n        }\n        clearTimeout(this._mouseMoveTimeout)\n\n        this._mouseMoveTimeout = setTimeout(() => {\n            this._capture(this._getProperties(e as MouseEvent, 'mousemove'))\n        }, 500)\n    }\n\n    private _capture(properties: Properties): void {\n        if (!window) {\n            return\n        }\n\n        // TODO we should be able to mask this\n        const url = window.location.href\n\n        this.buffer = this.buffer || {}\n\n        if (!this.buffer[url]) {\n            this.buffer[url] = []\n        }\n\n        this.buffer[url].push(properties)\n    }\n\n    private flush(): void {\n        if (!this.buffer || isEmptyObject(this.buffer)) {\n            return\n        }\n\n        this.instance.capture('$$heatmap', {\n            $heatmap_data: this.getAndClearBuffer(),\n        })\n    }\n}\n"]}
{"version":3,"file":"posthog-exceptions.js","sourceRoot":"","sources":["../../src/posthog-exceptions.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,iCAAiC,EAAE,MAAM,aAAa,CAAA;AAG/D,OAAO,EAAE,QAAQ,EAAE,MAAM,oBAAoB,CAAA;AAE7C,oCAAoC;AACpC,MAAM,CAAC,IAAM,0BAA0B,GAAG,KAAK,CAAA;AAE/C;IAGI,2BAA6B,QAAiB;;QAAjB,aAAQ,GAAR,QAAQ,CAAS;QAC1C,6EAA6E;QAC7E,IAAI,CAAC,eAAe;YAChB,CAAA,MAAA,IAAI,CAAC,QAAQ,CAAC,WAAW,0CAAE,KAAK,CAAC,iCAAiC,CAAC,KAAI,0BAA0B,CAAA;IACzG,CAAC;IAED,sBAAI,uCAAQ;aAAZ;YACI,uDAAuD;YACvD,OAAO,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,WAAW,CAAC,KAAK,EAAE,IAAI,CAAC,eAAe,CAAC,CAAA;QAC/E,CAAC;;;OAAA;IAED,+CAAmB,GAAnB,UAAoB,QAAwB;;QACxC,IAAM,6BAA6B,GAAG,QAAQ,CAAC,qBAAqB,CAAA;QAEpE,IAAI,CAAC,eAAe,GAAG,QAAQ,CAAC,6BAA6B,CAAC;YAC1D,CAAC,CAAC,6BAA6B,CAAC,QAAQ,IAAI,0BAA0B;YACtE,CAAC,CAAC,0BAA0B,CAAA;QAEhC,IAAI,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC;YAC5B,iDAAiD;YACjD,iEAAiE;YACjE,gEAAgE;YAChE,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,QAAQ;gBAC9B,GAAC,iCAAiC,IAAG,IAAI,CAAC,eAAe;oBAC3D,CAAA;QACN,CAAC;IACL,CAAC;IAED;;OAEG;IACH,8CAAkB,GAAlB,UAAmB,UAAsB;QACrC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,YAAY,EAAE,UAAU,EAAE;YAC5C,WAAW,EAAE,IAAI;YACjB,SAAS,EAAE,gBAAgB;YAC3B,IAAI,EAAE,IAAI,CAAC,QAAQ;SACtB,CAAC,CAAA;IACN,CAAC;IACL,wBAAC;AAAD,CAAC,AAzCD,IAyCC","sourcesContent":["import { EXCEPTION_CAPTURE_ENDPOINT_SUFFIX } from './constants'\nimport { PostHog } from './posthog-core'\nimport { DecideResponse, Properties } from './types'\nimport { isObject } from './utils/type-utils'\n\n// TODO: move this to /x/ as default\nexport const BASE_ERROR_ENDPOINT_SUFFIX = '/e/'\n\nexport class PostHogExceptions {\n    private _endpointSuffix: string\n\n    constructor(private readonly instance: PostHog) {\n        // TODO: once BASE_ERROR_ENDPOINT_SUFFIX is no longer /e/ this can be removed\n        this._endpointSuffix =\n            this.instance.persistence?.props[EXCEPTION_CAPTURE_ENDPOINT_SUFFIX] || BASE_ERROR_ENDPOINT_SUFFIX\n    }\n\n    get endpoint() {\n        // Always respect any api_host set by the client config\n        return this.instance.requestRouter.endpointFor('api', this._endpointSuffix)\n    }\n\n    afterDecideResponse(response: DecideResponse) {\n        const autocaptureExceptionsResponse = response.autocaptureExceptions\n\n        this._endpointSuffix = isObject(autocaptureExceptionsResponse)\n            ? autocaptureExceptionsResponse.endpoint || BASE_ERROR_ENDPOINT_SUFFIX\n            : BASE_ERROR_ENDPOINT_SUFFIX\n\n        if (this.instance.persistence) {\n            // when we come to moving the endpoint to not /e/\n            // we'll want that to persist between startup and decide response\n            // TODO: once BASE_ENDPOINT is no longer /e/ this can be removed\n            this.instance.persistence.register({\n                [EXCEPTION_CAPTURE_ENDPOINT_SUFFIX]: this._endpointSuffix,\n            })\n        }\n    }\n\n    /**\n     * :TRICKY: Make sure we batch these requests\n     */\n    sendExceptionEvent(properties: Properties) {\n        this.instance.capture('$exception', properties, {\n            _noTruncate: true,\n            _batchKey: 'exceptionEvent',\n            _url: this.endpoint,\n        })\n    }\n}\n"]}
{"version":3,"file":"rate-limiter.js","sourceRoot":"","sources":["../../src/rate-limiter.ts"],"names":[],"mappings":"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","sourcesContent":["import { CAPTURE_RATE_LIMIT } from './constants'\nimport type { PostHog } from './posthog-core'\nimport { RequestResponse } from './types'\nimport { logger } from './utils/logger'\n\nconst ONE_MINUTE_IN_MILLISECONDS = 60 * 1000\nconst RATE_LIMIT_EVENT = '$$client_ingestion_warning'\n\ninterface CaptureResponse {\n    quota_limited?: string[]\n}\n\nexport class RateLimiter {\n    instance: PostHog\n    serverLimits: Record<string, number> = {}\n\n    captureEventsPerSecond: number\n    captureEventsBurstLimit: number\n    lastEventRateLimited = false\n\n    constructor(instance: PostHog) {\n        this.instance = instance\n\n        this.captureEventsPerSecond = instance.config.rate_limiting?.events_per_second || 10\n        this.captureEventsBurstLimit = Math.max(\n            instance.config.rate_limiting?.events_burst_limit || this.captureEventsPerSecond * 10,\n            this.captureEventsPerSecond\n        )\n\n        this.lastEventRateLimited = this.clientRateLimitContext(true).isRateLimited\n    }\n\n    public clientRateLimitContext(checkOnly = false): {\n        isRateLimited: boolean\n        remainingTokens: number\n    } {\n        // This is primarily to prevent runaway loops from flooding capture with millions of events for a single user.\n        // It's as much for our protection as theirs.\n        const now = new Date().getTime()\n        const bucket = this.instance.persistence?.get_property(CAPTURE_RATE_LIMIT) ?? {\n            tokens: this.captureEventsBurstLimit,\n            last: now,\n        }\n\n        bucket.tokens += ((now - bucket.last) / 1000) * this.captureEventsPerSecond\n        bucket.last = now\n\n        if (bucket.tokens > this.captureEventsBurstLimit) {\n            bucket.tokens = this.captureEventsBurstLimit\n        }\n\n        const isRateLimited = bucket.tokens < 1\n\n        if (!isRateLimited && !checkOnly) {\n            bucket.tokens = Math.max(0, bucket.tokens - 1)\n        }\n\n        if (isRateLimited && !this.lastEventRateLimited && !checkOnly) {\n            this.instance.capture(\n                RATE_LIMIT_EVENT,\n                {\n                    $$client_ingestion_warning_message: `posthog-js client rate limited. Config is set to ${this.captureEventsPerSecond} events per second and ${this.captureEventsBurstLimit} events burst limit.`,\n                },\n                {\n                    skip_client_rate_limiting: true,\n                }\n            )\n        }\n\n        this.lastEventRateLimited = isRateLimited\n        this.instance.persistence?.set_property(CAPTURE_RATE_LIMIT, bucket)\n\n        return {\n            isRateLimited,\n            remainingTokens: bucket.tokens,\n        }\n    }\n\n    public isServerRateLimited(batchKey: string | undefined): boolean {\n        const retryAfter = this.serverLimits[batchKey || 'events'] || false\n\n        if (retryAfter === false) {\n            return false\n        }\n        return new Date().getTime() < retryAfter\n    }\n\n    public checkForLimiting = (httpResponse: RequestResponse): void => {\n        const text = httpResponse.text\n\n        if (!text || !text.length) {\n            return\n        }\n\n        try {\n            const response: CaptureResponse = JSON.parse(text)\n            const quotaLimitedProducts = response.quota_limited || []\n            quotaLimitedProducts.forEach((batchKey) => {\n                logger.info(`[RateLimiter] ${batchKey || 'events'} is quota limited.`)\n                this.serverLimits[batchKey] = new Date().getTime() + ONE_MINUTE_IN_MILLISECONDS\n            })\n        } catch (e: any) {\n            logger.warn(`[RateLimiter] could not rate limit - continuing. Error: \"${e?.message}\"`, { text })\n            return\n        }\n    }\n}\n"]}
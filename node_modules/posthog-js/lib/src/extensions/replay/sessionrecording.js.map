{"version":3,"file":"sessionrecording.js","sourceRoot":"","sources":["../../../../src/extensions/replay/sessionrecording.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    CONSOLE_LOG_RECORDING_ENABLED_SERVER_SIDE,\n    SESSION_RECORDING_CANVAS_RECORDING,\n    SESSION_RECORDING_ENABLED_SERVER_SIDE,\n    SESSION_RECORDING_IS_SAMPLED,\n    SESSION_RECORDING_MINIMUM_DURATION,\n    SESSION_RECORDING_NETWORK_PAYLOAD_CAPTURE,\n    SESSION_RECORDING_SAMPLE_RATE,\n} from '../../constants'\nimport {\n    estimateSize,\n    INCREMENTAL_SNAPSHOT_EVENT_TYPE,\n    recordOptions,\n    rrwebRecord,\n    splitBuffer,\n    truncateLargeConsoleLogs,\n} from './sessionrecording-utils'\nimport { PostHog } from '../../posthog-core'\nimport { DecideResponse, FlagVariant, NetworkRecordOptions, NetworkRequest, Properties } from '../../types'\nimport {\n    customEvent,\n    EventType,\n    type eventWithTime,\n    IncrementalSource,\n    type listenerHandler,\n    RecordPlugin,\n} from '@rrweb/types'\n\nimport { isBoolean, isFunction, isNullish, isNumber, isObject, isString, isUndefined } from '../../utils/type-utils'\nimport { logger } from '../../utils/logger'\nimport { assignableWindow, document, window } from '../../utils/globals'\nimport { buildNetworkRequestOptions } from './config'\nimport { isLocalhost } from '../../utils/request-utils'\nimport { MutationRateLimiter } from './mutation-rate-limiter'\nimport { gzipSync, strFromU8, strToU8 } from 'fflate'\n\ntype SessionStartReason =\n    | 'sampling_override'\n    | 'recording_initialized'\n    | 'linked_flag_match'\n    | 'linked_flag_override'\n    | 'sampling'\n    | 'session_id_changed'\n\nconst BASE_ENDPOINT = '/s/'\n\nconst FIVE_MINUTES = 1000 * 60 * 5\nconst TWO_SECONDS = 2000\nexport const RECORDING_IDLE_THRESHOLD_MS = FIVE_MINUTES\nconst ONE_KB = 1024\nconst PARTIAL_COMPRESSION_THRESHOLD = ONE_KB\nexport const RECORDING_MAX_EVENT_SIZE = ONE_KB * ONE_KB * 0.9 // ~1mb (with some wiggle room)\nexport const RECORDING_BUFFER_TIMEOUT = 2000 // 2 seconds\nexport const SESSION_RECORDING_BATCH_KEY = 'recordings'\n\n// NOTE: Importing this type is problematic as we can't safely bundle it to a TS definition so, instead we redefine.\n// import type { record } from 'rrweb2/typings'\n// import type { recordOptions } from 'rrweb/typings/types'\n\nconst ACTIVE_SOURCES = [\n    IncrementalSource.MouseMove,\n    IncrementalSource.MouseInteraction,\n    IncrementalSource.Scroll,\n    IncrementalSource.ViewportResize,\n    IncrementalSource.Input,\n    IncrementalSource.TouchMove,\n    IncrementalSource.MediaInteraction,\n    IncrementalSource.Drag,\n]\n\n/**\n * Session recording starts in buffering mode while waiting for decide response\n * Once the response is received it might be disabled, active or sampled\n * When sampled that means a sample rate is set and the last time the session id was rotated\n * the sample rate determined this session should be sent to the server.\n */\ntype SessionRecordingStatus = 'disabled' | 'sampled' | 'active' | 'buffering'\n\nexport interface SnapshotBuffer {\n    size: number\n    data: any[]\n    sessionId: string\n    windowId: string\n}\n\ninterface QueuedRRWebEvent {\n    rrwebMethod: () => void\n    attempt: number\n    // the timestamp this was first put into this queue\n    enqueuedAt: number\n}\n\ninterface SessionIdlePayload {\n    eventTimestamp: number\n    lastActivityTimestamp: number\n    threshold: number\n    bufferLength: number\n    bufferSize: number\n}\n\nconst newQueuedEvent = (rrwebMethod: () => void): QueuedRRWebEvent => ({\n    rrwebMethod,\n    enqueuedAt: Date.now(),\n    attempt: 1,\n})\n\nconst LOGGER_PREFIX = '[SessionRecording]'\n\ntype compressedFullSnapshotEvent = {\n    type: EventType.FullSnapshot\n    data: string\n}\n\ntype compressedIncrementalSnapshotEvent = {\n    type: EventType.IncrementalSnapshot\n    data: {\n        source: IncrementalSource\n        texts: string\n        attributes: string\n        removes: string\n        adds: string\n    }\n}\n\ntype compressedIncrementalStyleSnapshotEvent = {\n    type: EventType.IncrementalSnapshot\n    data: {\n        source: IncrementalSource.StyleSheetRule\n        id?: number\n        styleId?: number\n        replace?: string\n        replaceSync?: string\n        adds: string\n        removes: string\n    }\n}\n\nexport type compressedEvent =\n    | compressedIncrementalStyleSnapshotEvent\n    | compressedFullSnapshotEvent\n    | compressedIncrementalSnapshotEvent\nexport type compressedEventWithTime = compressedEvent & {\n    timestamp: number\n    delay?: number\n    // marker for compression version\n    cv: '2024-10'\n}\n\nfunction gzipToString(data: unknown): string {\n    return strFromU8(gzipSync(strToU8(JSON.stringify(data))), true)\n}\n\n// rrweb's packer takes an event and returns a string or the reverse on unpact,\n// but we want to be able to inspect metadata during ingestion, and don't want to compress the entire event\n// so we have a custom packer that only compresses part of some events\nfunction compressEvent(event: eventWithTime): eventWithTime | compressedEventWithTime {\n    const originalSize = estimateSize(event)\n    if (originalSize < PARTIAL_COMPRESSION_THRESHOLD) {\n        return event\n    }\n\n    try {\n        if (event.type === EventType.FullSnapshot) {\n            return {\n                ...event,\n                data: gzipToString(event.data),\n                cv: '2024-10',\n            }\n        }\n        if (event.type === EventType.IncrementalSnapshot && event.data.source === IncrementalSource.Mutation) {\n            return {\n                ...event,\n                cv: '2024-10',\n                data: {\n                    ...event.data,\n                    texts: gzipToString(event.data.texts),\n                    attributes: gzipToString(event.data.attributes),\n                    removes: gzipToString(event.data.removes),\n                    adds: gzipToString(event.data.adds),\n                },\n            }\n        }\n        if (event.type === EventType.IncrementalSnapshot && event.data.source === IncrementalSource.StyleSheetRule) {\n            return {\n                ...event,\n                cv: '2024-10',\n                data: {\n                    ...event.data,\n                    adds: gzipToString(event.data.adds),\n                    removes: gzipToString(event.data.removes),\n                },\n            }\n        }\n    } catch (e) {\n        logger.error(LOGGER_PREFIX + ' could not compress event - will use uncompressed event', e)\n    }\n    return event\n}\n\nfunction isSessionIdleEvent(e: eventWithTime): e is eventWithTime & customEvent {\n    return e.type === EventType.Custom && e.data.tag === 'sessionIdle'\n}\n\nexport class SessionRecording {\n    private _endpoint: string\n    private flushBufferTimer?: any\n\n    // we have a buffer - that contains PostHog snapshot events ready to be sent to the server\n    private buffer: SnapshotBuffer\n    // and a queue - that contains rrweb events that we want to send to rrweb, but rrweb wasn't able to accept them yet\n    private queuedRRWebEvents: QueuedRRWebEvent[] = []\n\n    private mutationRateLimiter?: MutationRateLimiter\n    private _captureStarted: boolean\n    private stopRrweb: listenerHandler | undefined\n    private receivedDecide: boolean\n    private isIdle = false\n\n    private _linkedFlagSeen: boolean = false\n    private _lastActivityTimestamp: number = Date.now()\n    private windowId: string\n    private sessionId: string\n    private _linkedFlag: string | FlagVariant | null = null\n\n    private _fullSnapshotTimer?: ReturnType<typeof setInterval>\n\n    private _removePageViewCaptureHook: (() => void) | undefined = undefined\n    private _onSessionIdListener: (() => void) | undefined = undefined\n    private _persistDecideOnSessionListener: (() => void) | undefined = undefined\n    private _samplingSessionListener: (() => void) | undefined = undefined\n\n    // if pageview capture is disabled\n    // then we can manually track href changes\n    private _lastHref?: string\n\n    // Util to help developers working on this feature manually override\n    _forceAllowLocalhostNetworkCapture = false\n\n    private get sessionIdleThresholdMilliseconds(): number {\n        return this.instance.config.session_recording.session_idle_threshold_ms || RECORDING_IDLE_THRESHOLD_MS\n    }\n\n    private get rrwebRecord(): rrwebRecord | undefined {\n        return assignableWindow?.__PosthogExtensions__?.rrweb?.record\n    }\n\n    public get started(): boolean {\n        // TODO could we use status instead of _captureStarted?\n        return this._captureStarted\n    }\n\n    private get sessionManager() {\n        if (!this.instance.sessionManager) {\n            throw new Error(LOGGER_PREFIX + ' must be started with a valid sessionManager.')\n        }\n\n        return this.instance.sessionManager\n    }\n\n    private get fullSnapshotIntervalMillis(): number {\n        return this.instance.config.session_recording?.full_snapshot_interval_millis || FIVE_MINUTES\n    }\n\n    private get isSampled(): boolean | null {\n        const currentValue = this.instance.get_property(SESSION_RECORDING_IS_SAMPLED)\n        return isBoolean(currentValue) ? currentValue : null\n    }\n\n    private get sessionDuration(): number | null {\n        const mostRecentSnapshot = this.buffer?.data[this.buffer?.data.length - 1]\n        const { sessionStartTimestamp } = this.sessionManager.checkAndGetSessionAndWindowId(true)\n        return mostRecentSnapshot ? mostRecentSnapshot.timestamp - sessionStartTimestamp : null\n    }\n\n    private get isRecordingEnabled() {\n        const enabled_server_side = !!this.instance.get_property(SESSION_RECORDING_ENABLED_SERVER_SIDE)\n        const enabled_client_side = !this.instance.config.disable_session_recording\n        return window && enabled_server_side && enabled_client_side\n    }\n\n    private get isConsoleLogCaptureEnabled() {\n        const enabled_server_side = !!this.instance.get_property(CONSOLE_LOG_RECORDING_ENABLED_SERVER_SIDE)\n        const enabled_client_side = this.instance.config.enable_recording_console_log\n        return enabled_client_side ?? enabled_server_side\n    }\n\n    private get canvasRecording(): { enabled: boolean; fps: number; quality: number } | undefined {\n        const canvasRecording_server_side = this.instance.get_property(SESSION_RECORDING_CANVAS_RECORDING)\n        return canvasRecording_server_side && canvasRecording_server_side.fps && canvasRecording_server_side.quality\n            ? {\n                  enabled: canvasRecording_server_side.enabled,\n                  fps: canvasRecording_server_side.fps,\n                  quality: canvasRecording_server_side.quality,\n              }\n            : undefined\n    }\n\n    // network payload capture config has three parts\n    // each can be configured server side or client side\n    private get networkPayloadCapture():\n        | Pick<NetworkRecordOptions, 'recordHeaders' | 'recordBody' | 'recordPerformance'>\n        | undefined {\n        const networkPayloadCapture_server_side = this.instance.get_property(SESSION_RECORDING_NETWORK_PAYLOAD_CAPTURE)\n        const networkPayloadCapture_client_side = {\n            recordHeaders: this.instance.config.session_recording?.recordHeaders,\n            recordBody: this.instance.config.session_recording?.recordBody,\n        }\n        const headersEnabled =\n            networkPayloadCapture_client_side?.recordHeaders || networkPayloadCapture_server_side?.recordHeaders\n        const bodyEnabled =\n            networkPayloadCapture_client_side?.recordBody || networkPayloadCapture_server_side?.recordBody\n        const clientConfigForPerformanceCapture = isObject(this.instance.config.capture_performance)\n            ? this.instance.config.capture_performance.network_timing\n            : this.instance.config.capture_performance\n        const networkTimingEnabled = !!(isBoolean(clientConfigForPerformanceCapture)\n            ? clientConfigForPerformanceCapture\n            : networkPayloadCapture_server_side?.capturePerformance)\n\n        return headersEnabled || bodyEnabled || networkTimingEnabled\n            ? { recordHeaders: headersEnabled, recordBody: bodyEnabled, recordPerformance: networkTimingEnabled }\n            : undefined\n    }\n\n    private get sampleRate(): number | null {\n        const rate = this.instance.get_property(SESSION_RECORDING_SAMPLE_RATE)\n        return isNumber(rate) ? rate : null\n    }\n\n    private get minimumDuration(): number | null {\n        const duration = this.instance.get_property(SESSION_RECORDING_MINIMUM_DURATION)\n        return isNumber(duration) ? duration : null\n    }\n\n    /**\n     * defaults to buffering mode until a decide response is received\n     * once a decide response is received status can be disabled, active or sampled\n     */\n    private get status(): SessionRecordingStatus {\n        if (!this.receivedDecide) {\n            return 'buffering'\n        }\n\n        if (!this.isRecordingEnabled) {\n            return 'disabled'\n        }\n\n        if (!isNullish(this._linkedFlag) && !this._linkedFlagSeen) {\n            return 'buffering'\n        }\n\n        if (isBoolean(this.isSampled)) {\n            return this.isSampled ? 'sampled' : 'disabled'\n        } else {\n            return 'active'\n        }\n    }\n\n    constructor(private readonly instance: PostHog) {\n        this._captureStarted = false\n        this._endpoint = BASE_ENDPOINT\n        this.stopRrweb = undefined\n        this.receivedDecide = false\n\n        if (!this.instance.sessionManager) {\n            logger.error(LOGGER_PREFIX + ' started without valid sessionManager')\n            throw new Error(LOGGER_PREFIX + ' started without valid sessionManager. This is a bug.')\n        }\n\n        // we know there's a sessionManager, so don't need to start without a session id\n        const { sessionId, windowId } = this.sessionManager.checkAndGetSessionAndWindowId()\n        this.sessionId = sessionId\n        this.windowId = windowId\n\n        this.buffer = this.clearBuffer()\n\n        if (this.sessionIdleThresholdMilliseconds >= this.sessionManager.sessionTimeoutMs) {\n            logger.warn(\n                LOGGER_PREFIX +\n                    ` session_idle_threshold_ms (${this.sessionIdleThresholdMilliseconds}) is greater than the session timeout (${this.sessionManager.sessionTimeoutMs}). Session will never be detected as idle`\n            )\n        }\n    }\n\n    private _onBeforeUnload = (): void => {\n        this._flushBuffer()\n    }\n\n    private _onOffline = (): void => {\n        this._tryAddCustomEvent('browser offline', {})\n    }\n\n    private _onOnline = (): void => {\n        this._tryAddCustomEvent('browser online', {})\n    }\n\n    private _onVisibilityChange = (): void => {\n        if (document?.visibilityState) {\n            const label = 'window ' + document.visibilityState\n            this._tryAddCustomEvent(label, {})\n        }\n    }\n\n    startIfEnabledOrStop(startReason?: SessionStartReason) {\n        if (this.isRecordingEnabled) {\n            this._startCapture(startReason)\n\n            // calling addEventListener multiple times is safe and will not add duplicates\n            window?.addEventListener('beforeunload', this._onBeforeUnload)\n            window?.addEventListener('offline', this._onOffline)\n            window?.addEventListener('online', this._onOnline)\n            window?.addEventListener('visibilitychange', this._onVisibilityChange)\n\n            // on reload there might be an already sampled session that should be continued before decide response,\n            // so we call this here _and_ in the decide response\n            this._setupSampling()\n\n            if (isNullish(this._removePageViewCaptureHook)) {\n                // :TRICKY: rrweb does not capture navigation within SPA-s, so hook into our $pageview events to get access to all events.\n                //   Dropping the initial event is fine (it's always captured by rrweb).\n                this._removePageViewCaptureHook = this.instance._addCaptureHook((eventName) => {\n                    // If anything could go wrong here it has the potential to block the main loop,\n                    // so we catch all errors.\n                    try {\n                        if (eventName === '$pageview') {\n                            const href = window ? this._maskUrl(window.location.href) : ''\n                            if (!href) {\n                                return\n                            }\n                            this._tryAddCustomEvent('$pageview', { href })\n                        }\n                    } catch (e) {\n                        logger.error('Could not add $pageview to rrweb session', e)\n                    }\n                })\n            }\n\n            if (!this._onSessionIdListener) {\n                this._onSessionIdListener = this.sessionManager.onSessionId((sessionId, windowId, changeReason) => {\n                    if (changeReason) {\n                        this._tryAddCustomEvent('$session_id_change', { sessionId, windowId, changeReason })\n                    }\n                })\n            }\n        } else {\n            this.stopRecording()\n        }\n    }\n\n    stopRecording() {\n        if (this._captureStarted && this.stopRrweb) {\n            this.stopRrweb()\n            this.stopRrweb = undefined\n            this._captureStarted = false\n\n            window?.removeEventListener('beforeunload', this._onBeforeUnload)\n            window?.removeEventListener('offline', this._onOffline)\n            window?.removeEventListener('online', this._onOnline)\n            window?.removeEventListener('visibilitychange', this._onVisibilityChange)\n\n            this.clearBuffer()\n            clearInterval(this._fullSnapshotTimer)\n\n            this._removePageViewCaptureHook?.()\n            this._removePageViewCaptureHook = undefined\n            this._onSessionIdListener?.()\n            this._onSessionIdListener = undefined\n            this._samplingSessionListener?.()\n            this._samplingSessionListener = undefined\n\n            logger.info(LOGGER_PREFIX + ' stopped')\n        }\n    }\n\n    private makeSamplingDecision(sessionId: string): void {\n        const sessionIdChanged = this.sessionId !== sessionId\n\n        // capture the current sample rate,\n        // because it is re-used multiple times\n        // and the bundler won't minimise any of the references\n        const currentSampleRate = this.sampleRate\n\n        if (!isNumber(currentSampleRate)) {\n            this.instance.persistence?.register({\n                [SESSION_RECORDING_IS_SAMPLED]: null,\n            })\n            return\n        }\n\n        const storedIsSampled = this.isSampled\n\n        /**\n         * if we get this far then we should make a sampling decision.\n         * When the session id changes or there is no stored sampling decision for this session id\n         * then we should make a new decision.\n         *\n         * Otherwise, we should use the stored decision.\n         */\n        let shouldSample: boolean\n        const makeDecision = sessionIdChanged || !isBoolean(storedIsSampled)\n        if (makeDecision) {\n            const randomNumber = Math.random()\n            shouldSample = randomNumber < currentSampleRate\n        } else {\n            shouldSample = storedIsSampled\n        }\n\n        if (makeDecision) {\n            if (shouldSample) {\n                this._reportStarted('sampling')\n            } else {\n                logger.warn(\n                    LOGGER_PREFIX +\n                        ` Sample rate (${currentSampleRate}) has determined that this sessionId (${sessionId}) will not be sent to the server.`\n                )\n            }\n\n            this._tryAddCustomEvent('samplingDecisionMade', {\n                sampleRate: currentSampleRate,\n                isSampled: shouldSample,\n            })\n        }\n\n        this.instance.persistence?.register({\n            [SESSION_RECORDING_IS_SAMPLED]: shouldSample,\n        })\n    }\n\n    afterDecideResponse(response: DecideResponse) {\n        this._persistDecideResponse(response)\n\n        this._linkedFlag = response.sessionRecording?.linkedFlag || null\n\n        if (response.sessionRecording?.endpoint) {\n            this._endpoint = response.sessionRecording?.endpoint\n        }\n\n        this._setupSampling()\n\n        if (!isNullish(this._linkedFlag) && !this._linkedFlagSeen) {\n            const linkedFlag = isString(this._linkedFlag) ? this._linkedFlag : this._linkedFlag.flag\n            const linkedVariant = isString(this._linkedFlag) ? null : this._linkedFlag.variant\n            this.instance.onFeatureFlags((_flags, variants) => {\n                const flagIsPresent = isObject(variants) && linkedFlag in variants\n                const linkedFlagMatches = linkedVariant ? variants[linkedFlag] === linkedVariant : flagIsPresent\n                if (linkedFlagMatches) {\n                    const payload = {\n                        linkedFlag,\n                        linkedVariant,\n                    }\n                    const tag = 'linked flag matched'\n                    logger.info(LOGGER_PREFIX + ' ' + tag, payload)\n                    this._tryAddCustomEvent(tag, payload)\n                    this._reportStarted('linked_flag_match')\n                }\n                this._linkedFlagSeen = linkedFlagMatches\n            })\n        }\n\n        this.receivedDecide = true\n        this.startIfEnabledOrStop()\n    }\n\n    /**\n     * This might be called more than once so needs to be idempotent\n     */\n    private _setupSampling() {\n        if (isNumber(this.sampleRate) && isNullish(this._samplingSessionListener)) {\n            this._samplingSessionListener = this.sessionManager.onSessionId((sessionId) => {\n                this.makeSamplingDecision(sessionId)\n            })\n        }\n    }\n\n    private _persistDecideResponse(response: DecideResponse): void {\n        if (this.instance.persistence) {\n            const persistence = this.instance.persistence\n\n            const persistResponse = () => {\n                const receivedSampleRate = response.sessionRecording?.sampleRate\n\n                const parsedSampleRate = isNullish(receivedSampleRate) ? null : parseFloat(receivedSampleRate)\n                const receivedMinimumDuration = response.sessionRecording?.minimumDurationMilliseconds\n\n                persistence.register({\n                    [SESSION_RECORDING_ENABLED_SERVER_SIDE]: !!response['sessionRecording'],\n                    [CONSOLE_LOG_RECORDING_ENABLED_SERVER_SIDE]: response.sessionRecording?.consoleLogRecordingEnabled,\n                    [SESSION_RECORDING_NETWORK_PAYLOAD_CAPTURE]: {\n                        capturePerformance: response.capturePerformance,\n                        ...response.sessionRecording?.networkPayloadCapture,\n                    },\n                    [SESSION_RECORDING_CANVAS_RECORDING]: {\n                        enabled: response.sessionRecording?.recordCanvas,\n                        fps: response.sessionRecording?.canvasFps,\n                        quality: response.sessionRecording?.canvasQuality,\n                    },\n                    [SESSION_RECORDING_SAMPLE_RATE]: parsedSampleRate,\n                    [SESSION_RECORDING_MINIMUM_DURATION]: isUndefined(receivedMinimumDuration)\n                        ? null\n                        : receivedMinimumDuration,\n                })\n            }\n\n            persistResponse()\n\n            // in case we see multiple decide responses, we should only listen with the response from the most recent one\n            this._persistDecideOnSessionListener?.()\n            this._persistDecideOnSessionListener = this.sessionManager.onSessionId(persistResponse)\n        }\n    }\n\n    log(message: string, level: 'log' | 'warn' | 'error' = 'log') {\n        this.instance.sessionRecording?.onRRwebEmit({\n            type: 6,\n            data: {\n                plugin: 'rrweb/console@1',\n                payload: {\n                    level,\n                    trace: [],\n                    // Even though it is a string we stringify it as that's what rrweb expects\n                    payload: [JSON.stringify(message)],\n                },\n            },\n            timestamp: Date.now(),\n        })\n    }\n\n    private _startCapture(startReason?: SessionStartReason) {\n        if (isUndefined(Object.assign) || isUndefined(Array.from)) {\n            // According to the rrweb docs, rrweb is not supported on IE11 and below:\n            // \"rrweb does not support IE11 and below because it uses the MutationObserver API which was supported by these browsers.\"\n            // https://github.com/rrweb-io/rrweb/blob/master/guide.md#compatibility-note\n            //\n            // However, MutationObserver does exist on IE11, it just doesn't work well and does not detect all changes.\n            // Instead, when we load \"recorder.js\", the first JS error is about \"Object.assign\" and \"Array.from\" being undefined.\n            // Thus instead of MutationObserver, we look for this function and block recording if it's undefined.\n            return\n        }\n\n        // We do not switch recorder versions midway through a recording.\n        // do not start if explicitly disabled or if the user has opted out\n        if (\n            this._captureStarted ||\n            this.instance.config.disable_session_recording ||\n            this.instance.consent.isOptedOut()\n        ) {\n            return\n        }\n\n        this._captureStarted = true\n        // We want to ensure the sessionManager is reset if necessary on load of the recorder\n        this.sessionManager.checkAndGetSessionAndWindowId()\n\n        // If recorder.js is already loaded (if array.full.js snippet is used or posthog-js/dist/recorder is\n        // imported), don't load script. Otherwise, remotely import recorder.js from cdn since it hasn't been loaded.\n        if (!this.rrwebRecord) {\n            assignableWindow.__PosthogExtensions__?.loadExternalDependency?.(this.instance, 'recorder', (err) => {\n                if (err) {\n                    return logger.error(LOGGER_PREFIX + ` could not load recorder`, err)\n                }\n\n                this._onScriptLoaded()\n            })\n        } else {\n            this._onScriptLoaded()\n        }\n\n        logger.info(LOGGER_PREFIX + ' starting')\n        if (this.status === 'active') {\n            this._reportStarted(startReason || 'recording_initialized')\n        }\n    }\n\n    private isInteractiveEvent(event: eventWithTime) {\n        return (\n            event.type === INCREMENTAL_SNAPSHOT_EVENT_TYPE &&\n            ACTIVE_SOURCES.indexOf(event.data?.source as IncrementalSource) !== -1\n        )\n    }\n\n    private _updateWindowAndSessionIds(event: eventWithTime) {\n        // Some recording events are triggered by non-user events (e.g. \"X minutes ago\" text updating on the screen).\n        // We don't want to extend the session or trigger a new session in these cases. These events are designated by event\n        // type -> incremental update, and source -> mutation.\n\n        const isUserInteraction = this.isInteractiveEvent(event)\n\n        if (!isUserInteraction && !this.isIdle) {\n            // We check if the lastActivityTimestamp is old enough to go idle\n            const timeSinceLastActivity = event.timestamp - this._lastActivityTimestamp\n            if (timeSinceLastActivity > this.sessionIdleThresholdMilliseconds) {\n                // we mark as idle right away,\n                // or else we get multiple idle events\n                // if there are lots of non-user activity events being emitted\n                this.isIdle = true\n\n                // don't take full snapshots while idle\n                clearInterval(this._fullSnapshotTimer)\n\n                this._tryAddCustomEvent('sessionIdle', {\n                    eventTimestamp: event.timestamp,\n                    lastActivityTimestamp: this._lastActivityTimestamp,\n                    threshold: this.sessionIdleThresholdMilliseconds,\n                    bufferLength: this.buffer.data.length,\n                    bufferSize: this.buffer.size,\n                })\n\n                // proactively flush the buffer in case the session is idle for a long time\n                this._flushBuffer()\n            }\n        }\n\n        let returningFromIdle = false\n        if (isUserInteraction) {\n            this._lastActivityTimestamp = event.timestamp\n            if (this.isIdle) {\n                // Remove the idle state\n                this.isIdle = false\n                this._tryAddCustomEvent('sessionNoLongerIdle', {\n                    reason: 'user activity',\n                    type: event.type,\n                })\n                returningFromIdle = true\n            }\n        }\n\n        if (this.isIdle) {\n            return\n        }\n\n        // We only want to extend the session if it is an interactive event.\n        const { windowId, sessionId } = this.sessionManager.checkAndGetSessionAndWindowId(\n            !isUserInteraction,\n            event.timestamp\n        )\n\n        const sessionIdChanged = this.sessionId !== sessionId\n        const windowIdChanged = this.windowId !== windowId\n\n        this.windowId = windowId\n        this.sessionId = sessionId\n\n        if (sessionIdChanged || windowIdChanged) {\n            this.stopRecording()\n            this.startIfEnabledOrStop('session_id_changed')\n        } else if (returningFromIdle) {\n            this._scheduleFullSnapshot()\n        }\n    }\n\n    private _tryRRWebMethod(queuedRRWebEvent: QueuedRRWebEvent): boolean {\n        try {\n            queuedRRWebEvent.rrwebMethod()\n            return true\n        } catch (e) {\n            // Sometimes a race can occur where the recorder is not fully started yet\n            if (this.queuedRRWebEvents.length < 10) {\n                this.queuedRRWebEvents.push({\n                    enqueuedAt: queuedRRWebEvent.enqueuedAt || Date.now(),\n                    attempt: queuedRRWebEvent.attempt++,\n                    rrwebMethod: queuedRRWebEvent.rrwebMethod,\n                })\n            } else {\n                logger.warn(LOGGER_PREFIX + ' could not emit queued rrweb event.', e, queuedRRWebEvent)\n            }\n\n            return false\n        }\n    }\n\n    private _tryAddCustomEvent(tag: string, payload: any): boolean {\n        return this._tryRRWebMethod(newQueuedEvent(() => this.rrwebRecord!.addCustomEvent(tag, payload)))\n    }\n\n    private _tryTakeFullSnapshot(): boolean {\n        return this._tryRRWebMethod(newQueuedEvent(() => this.rrwebRecord!.takeFullSnapshot()))\n    }\n\n    private _onScriptLoaded() {\n        // rrweb config info: https://github.com/rrweb-io/rrweb/blob/7d5d0033258d6c29599fb08412202d9a2c7b9413/src/record/index.ts#L28\n        const sessionRecordingOptions: recordOptions<eventWithTime> = {\n            // select set of rrweb config options we expose to our users\n            // see https://github.com/rrweb-io/rrweb/blob/master/guide.md\n            blockClass: 'ph-no-capture',\n            blockSelector: undefined,\n            ignoreClass: 'ph-ignore-input',\n            maskTextClass: 'ph-mask',\n            maskTextSelector: undefined,\n            maskTextFn: undefined,\n            maskAllInputs: true,\n            maskInputOptions: { password: true },\n            maskInputFn: undefined,\n            slimDOMOptions: {},\n            collectFonts: false,\n            inlineStylesheet: true,\n            recordCrossOriginIframes: false,\n        }\n\n        // only allows user to set our allow-listed options\n        const userSessionRecordingOptions = this.instance.config.session_recording\n        for (const [key, value] of Object.entries(userSessionRecordingOptions || {})) {\n            if (key in sessionRecordingOptions) {\n                if (key === 'maskInputOptions') {\n                    // ensure password is set if not included\n                    sessionRecordingOptions.maskInputOptions = { password: true, ...value }\n                } else {\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    sessionRecordingOptions[key] = value\n                }\n            }\n        }\n\n        if (this.canvasRecording && this.canvasRecording.enabled) {\n            sessionRecordingOptions.recordCanvas = true\n            sessionRecordingOptions.sampling = { canvas: this.canvasRecording.fps }\n            sessionRecordingOptions.dataURLOptions = { type: 'image/webp', quality: this.canvasRecording.quality }\n        }\n\n        if (!this.rrwebRecord) {\n            logger.error(\n                LOGGER_PREFIX +\n                    'onScriptLoaded was called but rrwebRecord is not available. This indicates something has gone wrong.'\n            )\n            return\n        }\n\n        this.mutationRateLimiter =\n            this.mutationRateLimiter ??\n            new MutationRateLimiter(this.rrwebRecord, {\n                onBlockedNode: (id, node) => {\n                    const message = `Too many mutations on node '${id}'. Rate limiting. This could be due to SVG animations or something similar`\n                    logger.info(message, {\n                        node: node,\n                    })\n\n                    this.log(LOGGER_PREFIX + ' ' + message, 'warn')\n                },\n            })\n\n        const activePlugins = this._gatherRRWebPlugins()\n        this.stopRrweb = this.rrwebRecord({\n            emit: (event) => {\n                this.onRRwebEmit(event)\n            },\n            plugins: activePlugins,\n            ...sessionRecordingOptions,\n        })\n\n        // We reset the last activity timestamp, resetting the idle timer\n        this._lastActivityTimestamp = Date.now()\n        this.isIdle = false\n\n        this._tryAddCustomEvent('$session_options', {\n            sessionRecordingOptions,\n            activePlugins: activePlugins.map((p) => p?.name),\n        })\n\n        this._tryAddCustomEvent('$posthog_config', {\n            config: this.instance.config,\n        })\n    }\n\n    private _scheduleFullSnapshot(): void {\n        if (this._fullSnapshotTimer) {\n            clearInterval(this._fullSnapshotTimer)\n        }\n        // we don't schedule snapshots while idle\n        if (this.isIdle) {\n            return\n        }\n\n        const interval = this.fullSnapshotIntervalMillis\n        if (!interval) {\n            return\n        }\n\n        this._fullSnapshotTimer = setInterval(() => {\n            this._tryTakeFullSnapshot()\n        }, interval)\n    }\n\n    private _gatherRRWebPlugins() {\n        const plugins: RecordPlugin<unknown>[] = []\n\n        const recordConsolePlugin = assignableWindow.__PosthogExtensions__?.rrwebPlugins?.getRecordConsolePlugin\n        if (recordConsolePlugin && this.isConsoleLogCaptureEnabled) {\n            plugins.push(recordConsolePlugin())\n        }\n\n        const networkPlugin = assignableWindow.__PosthogExtensions__?.rrwebPlugins?.getRecordNetworkPlugin\n        if (this.networkPayloadCapture && isFunction(networkPlugin)) {\n            const canRecordNetwork = !isLocalhost() || this._forceAllowLocalhostNetworkCapture\n\n            if (canRecordNetwork) {\n                plugins.push(\n                    networkPlugin(buildNetworkRequestOptions(this.instance.config, this.networkPayloadCapture))\n                )\n            } else {\n                logger.info(LOGGER_PREFIX + ' NetworkCapture not started because we are on localhost.')\n            }\n        }\n\n        return plugins\n    }\n\n    onRRwebEmit(rawEvent: eventWithTime) {\n        this._processQueuedEvents()\n\n        if (!rawEvent || !isObject(rawEvent)) {\n            return\n        }\n\n        if (rawEvent.type === EventType.Meta) {\n            const href = this._maskUrl(rawEvent.data.href)\n            this._lastHref = href\n            if (!href) {\n                return\n            }\n            rawEvent.data.href = href\n        } else {\n            this._pageViewFallBack()\n        }\n\n        // we're processing a full snapshot, so we should reset the timer\n        if (rawEvent.type === EventType.FullSnapshot) {\n            this._scheduleFullSnapshot()\n        }\n\n        const throttledEvent = this.mutationRateLimiter\n            ? this.mutationRateLimiter.throttleMutations(rawEvent)\n            : rawEvent\n\n        if (!throttledEvent) {\n            return\n        }\n\n        // TODO: Re-add ensureMaxMessageSize once we are confident in it\n        const event = truncateLargeConsoleLogs(throttledEvent)\n\n        this._updateWindowAndSessionIds(event)\n\n        // When in an idle state we keep recording, but don't capture the events,\n        if (this.isIdle && !isSessionIdleEvent(event)) {\n            return\n        }\n\n        if (isSessionIdleEvent(event)) {\n            // session idle events have a timestamp when rrweb sees them\n            // which can artificially lengthen a session\n            // we know when we detected it based on the payload and can correct the timestamp\n            const payload = event.data.payload as SessionIdlePayload\n            if (payload) {\n                const lastActivity = payload.lastActivityTimestamp\n                const threshold = payload.threshold\n                event.timestamp = lastActivity + threshold\n            }\n        }\n\n        const eventToSend =\n            this.instance.config.session_recording.compress_events ?? true ? compressEvent(event) : event\n        const size = estimateSize(eventToSend)\n\n        const properties = {\n            $snapshot_bytes: size,\n            $snapshot_data: eventToSend,\n            $session_id: this.sessionId,\n            $window_id: this.windowId,\n        }\n\n        if (this.status !== 'disabled') {\n            this._captureSnapshotBuffered(properties)\n        } else {\n            this.clearBuffer()\n        }\n    }\n\n    private _pageViewFallBack() {\n        if (this.instance.config.capture_pageview || !window) {\n            return\n        }\n        const currentUrl = this._maskUrl(window.location.href)\n        if (this._lastHref !== currentUrl) {\n            this._tryAddCustomEvent('$url_changed', { href: currentUrl })\n            this._lastHref = currentUrl\n        }\n    }\n\n    private _processQueuedEvents() {\n        if (this.queuedRRWebEvents.length) {\n            // if rrweb isn't ready to accept events earlier then we queued them up\n            // now that emit has been called rrweb should be ready to accept them\n            // so, before we process this event, we try our queued events _once_ each\n            // we don't want to risk queuing more things and never exiting this loop!\n            // if they fail here, they'll be pushed into a new queue,\n            // and tried on the next loop.\n            // there is a risk of this queue growing in an uncontrolled manner,\n            // so its length is limited elsewhere\n            // for now this is to help us ensure we can capture events that happen\n            // and try to identify more about when it is failing\n            const itemsToProcess = [...this.queuedRRWebEvents]\n            this.queuedRRWebEvents = []\n            itemsToProcess.forEach((queuedRRWebEvent) => {\n                if (Date.now() - queuedRRWebEvent.enqueuedAt <= TWO_SECONDS) {\n                    this._tryRRWebMethod(queuedRRWebEvent)\n                }\n            })\n        }\n    }\n\n    private _maskUrl(url: string): string | undefined {\n        const userSessionRecordingOptions = this.instance.config.session_recording\n\n        if (userSessionRecordingOptions.maskNetworkRequestFn) {\n            let networkRequest: NetworkRequest | null | undefined = {\n                url,\n            }\n\n            // TODO we should deprecate this and use the same function for this masking and the rrweb/network plugin\n            // TODO or deprecate this and provide a new clearer name so this would be `maskURLPerformanceFn` or similar\n            networkRequest = userSessionRecordingOptions.maskNetworkRequestFn(networkRequest)\n\n            return networkRequest?.url\n        }\n\n        return url\n    }\n\n    private clearBuffer(): SnapshotBuffer {\n        this.buffer = {\n            size: 0,\n            data: [],\n            sessionId: this.sessionId,\n            windowId: this.windowId,\n        }\n        return this.buffer\n    }\n\n    private _flushBuffer(): SnapshotBuffer {\n        if (this.flushBufferTimer) {\n            clearTimeout(this.flushBufferTimer)\n            this.flushBufferTimer = undefined\n        }\n\n        const minimumDuration = this.minimumDuration\n        const sessionDuration = this.sessionDuration\n        // if we have old data in the buffer but the session has rotated then the\n        // session duration might be negative, in that case we want to flush the buffer\n        const isPositiveSessionDuration = isNumber(sessionDuration) && sessionDuration >= 0\n        const isBelowMinimumDuration =\n            isNumber(minimumDuration) && isPositiveSessionDuration && sessionDuration < minimumDuration\n\n        if (this.status === 'buffering' || isBelowMinimumDuration) {\n            this.flushBufferTimer = setTimeout(() => {\n                this._flushBuffer()\n            }, RECORDING_BUFFER_TIMEOUT)\n            return this.buffer\n        }\n\n        if (this.buffer.data.length > 0) {\n            const snapshotEvents = splitBuffer(this.buffer)\n            snapshotEvents.forEach((snapshotBuffer) => {\n                this._captureSnapshot({\n                    $snapshot_bytes: snapshotBuffer.size,\n                    $snapshot_data: snapshotBuffer.data,\n                    $session_id: snapshotBuffer.sessionId,\n                    $window_id: snapshotBuffer.windowId,\n                })\n            })\n        }\n\n        // buffer is empty, we clear it in case the session id has changed\n        return this.clearBuffer()\n    }\n\n    private _captureSnapshotBuffered(properties: Properties) {\n        const additionalBytes = 2 + (this.buffer?.data.length || 0) // 2 bytes for the array brackets and 1 byte for each comma\n        if (\n            !this.isIdle && // we never want to flush when idle\n            (this.buffer.size + properties.$snapshot_bytes + additionalBytes > RECORDING_MAX_EVENT_SIZE ||\n                this.buffer.sessionId !== this.sessionId)\n        ) {\n            this.buffer = this._flushBuffer()\n        }\n\n        this.buffer.size += properties.$snapshot_bytes\n        this.buffer.data.push(properties.$snapshot_data)\n\n        if (!this.flushBufferTimer && !this.isIdle) {\n            this.flushBufferTimer = setTimeout(() => {\n                this._flushBuffer()\n            }, RECORDING_BUFFER_TIMEOUT)\n        }\n    }\n\n    private _captureSnapshot(properties: Properties) {\n        // :TRICKY: Make sure we batch these requests, use a custom endpoint and don't truncate the strings.\n        this.instance.capture('$snapshot', properties, {\n            _url: this.instance.requestRouter.endpointFor('api', this._endpoint),\n            _noTruncate: true,\n            _batchKey: SESSION_RECORDING_BATCH_KEY,\n            skip_client_rate_limiting: true,\n        })\n    }\n\n    /**\n     * this ignores the linked flag config and causes capture to start\n     * (if recording would have started had the flag been received i.e. it does not override other config).\n     *\n     * It is not usual to call this directly,\n     * instead call `posthog.startSessionRecording({linked_flag: true})`\n     * */\n    public overrideLinkedFlag() {\n        this._linkedFlagSeen = true\n        this._reportStarted('linked_flag_override')\n    }\n\n    /**\n     * this ignores the sampling config and causes capture to start\n     * (if recording would have started had the flag been received i.e. it does not override other config).\n     *\n     * It is not usual to call this directly,\n     * instead call `posthog.startSessionRecording({sampling: true})`\n     * */\n    public overrideSampling() {\n        this.instance.persistence?.register({\n            // short-circuits the `makeSamplingDecision` function in the session recording module\n            [SESSION_RECORDING_IS_SAMPLED]: true,\n        })\n        this._reportStarted('sampling_override')\n    }\n\n    private _reportStarted(startReason: SessionStartReason, shouldReport: () => boolean = () => true) {\n        if (shouldReport()) {\n            this.instance.register_for_session({\n                $session_recording_start_reason: startReason,\n            })\n        }\n    }\n}\n"]}
{"version":3,"file":"sessionid.js","sourceRoot":"","sources":["../../src/sessionid.ts"],"names":[],"mappings":"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","sourcesContent":["import { PostHogPersistence } from './posthog-persistence'\nimport { SESSION_ID } from './constants'\nimport { sessionStore } from './storage'\nimport { PostHogConfig, SessionIdChangedCallback } from './types'\nimport { uuid7ToTimestampMs, uuidv7 } from './uuidv7'\nimport { window } from './utils/globals'\n\nimport { isArray, isNumber, isUndefined } from './utils/type-utils'\nimport { logger } from './utils/logger'\n\nconst MAX_SESSION_IDLE_TIMEOUT = 30 * 60 // 30 minutes\nconst MIN_SESSION_IDLE_TIMEOUT = 60 // 1 minute\nconst SESSION_LENGTH_LIMIT = 24 * 3600 * 1000 // 24 hours\n\nexport class SessionIdManager {\n    private readonly _sessionIdGenerator: () => string\n    private readonly _windowIdGenerator: () => string\n    private config: Partial<PostHogConfig>\n    private persistence: PostHogPersistence\n    private _windowId: string | null | undefined\n    private _sessionId: string | null | undefined\n    private readonly _window_id_storage_key: string\n    private readonly _primary_window_exists_storage_key: string\n    private _sessionStartTimestamp: number | null\n\n    private _sessionActivityTimestamp: number | null\n    private _sessionIdChangedHandlers: SessionIdChangedCallback[] = []\n    private readonly _sessionTimeoutMs: number\n\n    constructor(\n        config: Partial<PostHogConfig>,\n        persistence: PostHogPersistence,\n        sessionIdGenerator?: () => string,\n        windowIdGenerator?: () => string\n    ) {\n        this.config = config\n        this.persistence = persistence\n        this._windowId = undefined\n        this._sessionId = undefined\n        this._sessionStartTimestamp = null\n        this._sessionActivityTimestamp = null\n        this._sessionIdGenerator = sessionIdGenerator || uuidv7\n        this._windowIdGenerator = windowIdGenerator || uuidv7\n\n        const persistenceName = config['persistence_name'] || config['token']\n        let desiredTimeout = config['session_idle_timeout_seconds'] || MAX_SESSION_IDLE_TIMEOUT\n\n        if (!isNumber(desiredTimeout)) {\n            logger.warn('session_idle_timeout_seconds must be a number. Defaulting to 30 minutes.')\n            desiredTimeout = MAX_SESSION_IDLE_TIMEOUT\n        } else if (desiredTimeout > MAX_SESSION_IDLE_TIMEOUT) {\n            logger.warn('session_idle_timeout_seconds cannot be  greater than 30 minutes. Using 30 minutes instead.')\n        } else if (desiredTimeout < MIN_SESSION_IDLE_TIMEOUT) {\n            logger.warn('session_idle_timeout_seconds cannot be less than 60 seconds. Using 60 seconds instead.')\n        }\n\n        this._sessionTimeoutMs =\n            Math.min(Math.max(desiredTimeout, MIN_SESSION_IDLE_TIMEOUT), MAX_SESSION_IDLE_TIMEOUT) * 1000\n        this._window_id_storage_key = 'ph_' + persistenceName + '_window_id'\n        this._primary_window_exists_storage_key = 'ph_' + persistenceName + '_primary_window_exists'\n\n        // primary_window_exists is set when the DOM has been loaded and is cleared on unload\n        // if it exists here it means there was no unload which suggests this window is opened as a tab duplication, window.open, etc.\n        if (this._canUseSessionStorage()) {\n            const lastWindowId = sessionStore.parse(this._window_id_storage_key)\n\n            const primaryWindowExists = sessionStore.parse(this._primary_window_exists_storage_key)\n            if (lastWindowId && !primaryWindowExists) {\n                // Persist window from previous storage state\n                this._windowId = lastWindowId\n            } else {\n                // Wipe any reference to previous window id\n                sessionStore.remove(this._window_id_storage_key)\n            }\n            // Flag this session as having a primary window\n            sessionStore.set(this._primary_window_exists_storage_key, true)\n        }\n\n        if (this.config.bootstrap?.sessionID) {\n            try {\n                const sessionStartTimestamp = uuid7ToTimestampMs(this.config.bootstrap.sessionID)\n                this._setSessionId(this.config.bootstrap.sessionID, new Date().getTime(), sessionStartTimestamp)\n            } catch (e) {\n                logger.error('Invalid sessionID in bootstrap', e)\n            }\n        }\n\n        this._listenToReloadWindow()\n    }\n\n    get sessionTimeoutMs(): number {\n        return this._sessionTimeoutMs\n    }\n\n    onSessionId(callback: SessionIdChangedCallback): () => void {\n        // KLUDGE: when running in tests the handlers array was always undefined\n        // it's yucky but safe to set it here so that it's always definitely available\n        if (isUndefined(this._sessionIdChangedHandlers)) {\n            this._sessionIdChangedHandlers = []\n        }\n\n        this._sessionIdChangedHandlers.push(callback)\n        if (this._sessionId) {\n            callback(this._sessionId, this._windowId)\n        }\n        return () => {\n            this._sessionIdChangedHandlers = this._sessionIdChangedHandlers.filter((h) => h !== callback)\n        }\n    }\n\n    private _canUseSessionStorage(): boolean {\n        // We only want to use sessionStorage if persistence is enabled and not memory storage\n        return this.config.persistence !== 'memory' && !this.persistence.disabled && sessionStore.is_supported()\n    }\n\n    // Note: this tries to store the windowId in sessionStorage. SessionStorage is unique to the current window/tab,\n    // and persists page loads/reloads. So it's uniquely suited for storing the windowId. This function also respects\n    // when persistence is disabled (by user config) and when sessionStorage is not supported (it *should* be supported on all browsers),\n    // and in that case, it falls back to memory (which sadly, won't persist page loads)\n    private _setWindowId(windowId: string): void {\n        if (windowId !== this._windowId) {\n            this._windowId = windowId\n            if (this._canUseSessionStorage()) {\n                sessionStore.set(this._window_id_storage_key, windowId)\n            }\n        }\n    }\n\n    private _getWindowId(): string | null {\n        if (this._windowId) {\n            return this._windowId\n        }\n        if (this._canUseSessionStorage()) {\n            return sessionStore.parse(this._window_id_storage_key)\n        }\n        // New window id will be generated\n        return null\n    }\n\n    // Note: 'this.persistence.register' can be disabled in the config.\n    // In that case, this works by storing sessionId and the timestamp in memory.\n    private _setSessionId(\n        sessionId: string | null,\n        sessionActivityTimestamp: number | null,\n        sessionStartTimestamp: number | null\n    ): void {\n        if (\n            sessionId !== this._sessionId ||\n            sessionActivityTimestamp !== this._sessionActivityTimestamp ||\n            sessionStartTimestamp !== this._sessionStartTimestamp\n        ) {\n            this._sessionStartTimestamp = sessionStartTimestamp\n            this._sessionActivityTimestamp = sessionActivityTimestamp\n            this._sessionId = sessionId\n\n            this.persistence.register({\n                [SESSION_ID]: [sessionActivityTimestamp, sessionId, sessionStartTimestamp],\n            })\n        }\n    }\n\n    private _getSessionId(): [number, string, number] {\n        if (this._sessionId && this._sessionActivityTimestamp && this._sessionStartTimestamp) {\n            return [this._sessionActivityTimestamp, this._sessionId, this._sessionStartTimestamp]\n        }\n        const sessionId = this.persistence.props[SESSION_ID]\n\n        if (isArray(sessionId) && sessionId.length === 2) {\n            // Storage does not yet have a session start time. Add the last activity timestamp as the start time\n            sessionId.push(sessionId[0])\n        }\n\n        return sessionId || [0, null, 0]\n    }\n\n    // Resets the session id by setting it to null. On the subsequent call to checkAndGetSessionAndWindowId,\n    // new ids will be generated.\n    resetSessionId(): void {\n        this._setSessionId(null, null, null)\n    }\n\n    /*\n     * Listens to window unloads and removes the primaryWindowExists key from sessionStorage.\n     * Reloaded or fresh tabs created after a DOM unloads (reloading the same tab) WILL NOT have this primaryWindowExists flag in session storage.\n     * Cloned sessions (new tab, tab duplication, window.open(), ...) WILL have this primaryWindowExists flag in their copied session storage.\n     * We conditionally check the primaryWindowExists value in the constructor to decide if the window id in the last session storage should be carried over.\n     */\n    private _listenToReloadWindow(): void {\n        window?.addEventListener('beforeunload', () => {\n            if (this._canUseSessionStorage()) {\n                sessionStore.remove(this._primary_window_exists_storage_key)\n            }\n        })\n    }\n\n    /*\n     * This function returns the current sessionId and windowId. It should be used to\n     * access these values over directly calling `._sessionId` or `._windowId`.\n     * In addition to returning the sessionId and windowId, this function also manages cycling the\n     * sessionId and windowId when appropriate by doing the following:\n     *\n     * 1. If the sessionId or windowId is not set, it will generate a new one and store it.\n     * 2. If the readOnly param is set to false, it will:\n     *    a. Check if it has been > SESSION_CHANGE_THRESHOLD since the last call with this flag set.\n     *       If so, it will generate a new sessionId and store it.\n     *    b. Update the timestamp stored with the sessionId to ensure the current session is extended\n     *       for the appropriate amount of time.\n     *\n     * @param {boolean} readOnly (optional) Defaults to False. Should be set to True when the call to the function should not extend or cycle the session (e.g. being called for non-user generated events)\n     * @param {Number} timestamp (optional) Defaults to the current time. The timestamp to be stored with the sessionId (used when determining if a new sessionId should be generated)\n     */\n    checkAndGetSessionAndWindowId(readOnly = false, _timestamp: number | null = null) {\n        const timestamp = _timestamp || new Date().getTime()\n\n        // eslint-disable-next-line prefer-const\n        let [lastTimestamp, sessionId, startTimestamp] = this._getSessionId()\n        let windowId = this._getWindowId()\n\n        const sessionPastMaximumLength =\n            isNumber(startTimestamp) &&\n            startTimestamp > 0 &&\n            Math.abs(timestamp - startTimestamp) > SESSION_LENGTH_LIMIT\n\n        let valuesChanged = false\n        const noSessionId = !sessionId\n        const activityTimeout = !readOnly && Math.abs(timestamp - lastTimestamp) > this.sessionTimeoutMs\n        if (noSessionId || activityTimeout || sessionPastMaximumLength) {\n            sessionId = this._sessionIdGenerator()\n            windowId = this._windowIdGenerator()\n            logger.info('[SessionId] new session ID generated', {\n                sessionId,\n                windowId,\n                changeReason: { noSessionId, activityTimeout, sessionPastMaximumLength },\n            })\n            startTimestamp = timestamp\n            valuesChanged = true\n        } else if (!windowId) {\n            windowId = this._windowIdGenerator()\n            valuesChanged = true\n        }\n\n        const newTimestamp = lastTimestamp === 0 || !readOnly || sessionPastMaximumLength ? timestamp : lastTimestamp\n        const sessionStartTimestamp = startTimestamp === 0 ? new Date().getTime() : startTimestamp\n\n        this._setWindowId(windowId)\n        this._setSessionId(sessionId, newTimestamp, sessionStartTimestamp)\n\n        if (valuesChanged) {\n            this._sessionIdChangedHandlers.forEach((handler) =>\n                handler(\n                    sessionId,\n                    windowId,\n                    valuesChanged ? { noSessionId, activityTimeout, sessionPastMaximumLength } : undefined\n                )\n            )\n        }\n\n        return {\n            sessionId,\n            windowId,\n            sessionStartTimestamp,\n            changeReason: valuesChanged ? { noSessionId, activityTimeout, sessionPastMaximumLength } : undefined,\n        }\n    }\n}\n"]}